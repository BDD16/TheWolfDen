# **Malware Futex Analysis via KProbes and Syscall Hooking**

## **Overview**
This write-up documents an educational exploration of malware analysis and syscall interception using Linux kernel mechanisms. Specifically, it focuses on intercepting the `futex` syscall and selectively logging invocations related to the `passwd` binary. The primary goal is to show how a kernel module can be used to monitor and log sensitive interactions via `execve` and `futex` for security research.

---

## **Background**
The `futex` (Fast Userspace Mutex) syscall is widely used for low-level thread synchronization. Malicious binaries can exploit it for covert signaling or anti-debugging. In parallel, intercepting `execve` allows tracking of binary execution like `passwd`, potentially exposing sensitive inputs.

---

## **Key Goals**
1. Hook `__x64_sys_futex` to log futex arguments.
2. Detect and log invocations of the `passwd` binary.
3. Optionally dump futex chain behavior for further analysis.

---

## **Kernel Module Code**
```c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/kprobes.h>
#include <linux/uaccess.h>
#include <linux/sched.h>

static struct kprobe kp = {
    .symbol_name = "__x64_sys_futex"
};

static int handler_pre(struct kprobe *p, struct pt_regs *regs)
{
    unsigned long futex_addr = regs->di;  // First argument
    int futex_op = regs->si;              // Second argument
    int val = regs->dx;                   // Third argument

    printk(KERN_INFO "[HOOK] FUTEX called. Addr=0x%lx, Op=%d, Val=%d\n",
           futex_addr, futex_op, val);

    // Optional: match futex patterns used in known malware

    return 0;
}

static int __init hook_init(void)
{
    kp.pre_handler = handler_pre;
    if (register_kprobe(&kp) < 0) {
        printk(KERN_ERR "[KPROBE] Failed to register futex hook\n");
        return -1;
    }
    printk(KERN_INFO "[KPROBE] Futex hook registered successfully\n");
    return 0;
}

static void __exit hook_exit(void)
{
    unregister_kprobe(&kp);
    printk(KERN_INFO "[KPROBE] Futex hook unregistered\n");
}

module_init(hook_init);
module_exit(hook_exit);
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Blake Drizzle");
MODULE_DESCRIPTION("Educational futex syscall analysis via KProbes");
```

---

## **Userland Interceptor via LD_PRELOAD**
To intercept `execve`:
```c
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int (*real_execve)(const char*, char* const[], char* const[]) = NULL;

int execve(const char* pathname, char* const argv[], char* const envp[])
{
    if (!real_execve)
        real_execve = dlsym(RTLD_NEXT, "execve");

    if (strstr(pathname, "passwd")) {
        FILE *fp = fopen("/tmp/passwd_hook.log", "a");
        if (fp) {
            fprintf(fp, "[HOOK] execve: %s\n", pathname);
            fclose(fp);
        }
    }

    return real_execve(pathname, argv, envp);
}
```

Compile:
```sh
gcc -Wall -fPIC -shared -o hook.so hook.c -ldl
```
Run:
```sh
LD_PRELOAD=./hook.so /usr/bin/passwd
```

---

## **Syscall Symbol Lookup**
To find available symbols:
```sh
cat /proc/kallsyms | grep -i syscall
```
Look for `__x64_sys_futex`, `do_syscall_64`, `entry_SYSCALL_64_after_hwframe`.

---

## **Security Implications**
- Attackers can manipulate futex memory to control thread execution or evade debugging.
- Monitoring sensitive binaries like `passwd` can expose plaintext credentials if mishandled.
- Kernel space logging (via `printk`) and user space logging (via `fopen`) demonstrate two levels of observability.

---

## **Conclusion**
This exercise demonstrates hooking futex at the syscall level and tracking execve invocations in user space. Such methods help reverse engineers and blue teamers analyze the behavior of malware leveraging thread synchronization primitives.

> Please Use responsibly and only in secure, sandboxed environments. Math and Knowledge is Power!

---

## **References**
- [Linux Futex Syscall Documentation](https://man7.org/linux/man-pages/man2/futex.2.html)
- [Linux Kernel Kprobes Guide](https://www.kernel.org/doc/html/latest/trace/kprobes.html)
- [LD_PRELOAD Techniques](https://www.gnu.org/software/libc/manual/html_node/LD_005fPRELOAD.html)

